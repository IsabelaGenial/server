// --- Constantes ---
CONSTANTE INTEIRO MAX_SUPPORTED_FDS = 1024 // Substituição para FD_SETSIZE
CONSTANTE INTEIRO LISTEN_BACKLOG = 128   // Substituição para SOMAXCONN

// --- Estruturas ---
ESTRUTURA t_client:
    INTEIRO id
    PONTEIRO PARA CARACTERE write_buf
    ARRAY DE CARACTERE read_buf[40961] // 40KB + nulo
    INTEIRO read_len
FIM ESTRUTURA

// --- Variáveis Globais ---
ARRAY DE PONTEIROS PARA t_client g_clients[MAX_SUPPORTED_FDS]
ARRAY DE CARACTERE g_msg_buffer[42000]

INTEIRO g_server_fd = -1
INTEIRO g_next_client_id = 0
fd_set g_active_fds, g_read_fds, g_write_fds
INTEIRO g_max_fd = 0

// --- Funções Auxiliares ---

FUNÇÃO ft_putstr_fd(CONSTANTE PONTEIRO PARA CARACTERE str, INTEIRO fd)
    SE str NÃO FOR NULO ENTÃO
        write(fd, str, strlen(str))
    FIM SE
FIM FUNÇÃO

FUNÇÃO PONTEIRO PARA CARACTERE ft_strdup(CONSTANTE PONTEIRO PARA CARACTERE s)
    SE s FOR NULO ENTÃO RETORNAR NULO FIM SE
    TAMANHO len = strlen(s)
    PONTEIRO PARA CARACTERE new_s = (PONTEIRO PARA CARACTERE)malloc(len + 1)
    SE new_s FOR NULO ENTÃO RETORNAR NULO FIM SE
    strcpy(new_s, s)
    RETORNAR new_s
FIM FUNÇÃO

FUNÇÃO fatal_error()
    ft_putstr_fd("Fatal error\n", 2)
    SE g_server_fd != -1 ENTÃO
        close(g_server_fd)
    FIM SE
    PARA INTEIRO i = 0 ATÉ g_max_fd FAÇA
        SE g_clients[i] NÃO FOR NULO ENTÃO
            SE g_clients[i]->write_buf NÃO FOR NULO ENTÃO
                free(g_clients[i]->write_buf)
            FIM SE
            free(g_clients[i])
            g_clients[i] = NULO
            close(i)
        FIM SE
    FIM PARA
    exit(1)
FIM FUNÇÃO

FUNÇÃO broadcast_message(INTEIRO sender_fd, CONSTANTE PONTEIRO PARA CARACTERE message)
    PARA INTEIRO fd = 0 ATÉ g_max_fd FAÇA
        // Cliente existe, não é remetente, não é servidor
        SE FD_ISSET(fd, &g_active_fds) E g_clients[fd] NÃO FOR NULO E fd != sender_fd E fd != g_server_fd ENTÃO
            SE g_clients[fd]->write_buf FOR NULO ENTÃO
                g_clients[fd]->write_buf = ft_strdup(message)
                SE g_clients[fd]->write_buf FOR NULO ENTÃO fatal_error() FIM SE
            SENÃO
                PONTEIRO PARA CARACTERE old_buf = g_clients[fd]->write_buf
                PONTEIRO PARA CARACTERE new_buf = (PONTEIRO PARA CARACTERE)malloc(strlen(old_buf) + strlen(message) + 1)
                SE new_buf FOR NULO ENTÃO fatal_error() FIM SE
                strcpy(new_buf, old_buf)
                strcat(new_buf, message)
                free(old_buf)
                g_clients[fd]->write_buf = new_buf
            FIM SE
        FIM SE
    FIM PARA
FIM FUNÇÃO

FUNÇÃO remove_client(INTEIRO fd_to_remove)
    // A verificação `g_clients[fd_to_remove]` já garante que é um FD de cliente válido
    SE fd_to_remove < 0 OU fd_to_remove >= MAX_SUPPORTED_FDS OU g_clients[fd_to_remove] FOR NULO ENTÃO RETORNAR FIM SE

    sprintf(g_msg_buffer, "server: client %d just left\n", g_clients[fd_to_remove]->id)
    broadcast_message(fd_to_remove, g_msg_buffer)

    SE g_clients[fd_to_remove]->write_buf NÃO FOR NULO ENTÃO
        free(g_clients[fd_to_remove]->write_buf)
    FIM SE
    free(g_clients[fd_to_remove])
    g_clients[fd_to_remove] = NULO

    close(fd_to_remove)
    FD_CLR(fd_to_remove, &g_active_fds)

    SE fd_to_remove == g_max_fd ENTÃO
        g_max_fd = g_server_fd
        PARA INTEIRO i = 0 ATÉ fd_to_remove - 1 FAÇA // Nota: O loop original vai até < fd_to_remove, o que é correto para achar o novo max
            SE FD_ISSET(i, &g_active_fds) E i > g_max_fd ENTÃO
                g_max_fd = i
            FIM SE
        FIM PARA
    FIM SE
FIM FUNÇÃO

FUNÇÃO add_new_client()
    ESTRUTURA sockaddr_in client_addr
    socklen_t client_addr_len = sizeof(client_addr)
    INTEIRO client_fd

    client_fd = accept(g_server_fd, (PONTEIRO PARA sockaddr)&client_addr, &client_addr_len)
    SE client_fd < 0 ENTÃO RETORNAR FIM SE

    SE client_fd >= MAX_SUPPORTED_FDS ENTÃO
        close(client_fd)
        RETORNAR
    FIM SE

    g_clients[client_fd] = (PONTEIRO PARA t_client)calloc(1, sizeof(t_client))
    SE g_clients[client_fd] FOR NULO ENTÃO
        close(client_fd)
        fatal_error()
    FIM SE

    g_clients[client_fd]->id = g_next_client_id++
    g_clients[client_fd]->write_buf = NULO
    g_clients[client_fd]->read_len = 0

    FD_SET(client_fd, &g_active_fds)
    SE client_fd > g_max_fd ENTÃO
        g_max_fd = client_fd
    FIM SE

    sprintf(g_msg_buffer, "server: client %d just arrived\n", g_clients[client_fd]->id)
    broadcast_message(client_fd, g_msg_buffer) // client_fd é o "remetente" para não receber a própria msg
FIM FUNÇÃO

FUNÇÃO handle_client_read(INTEIRO fd)
    PONTEIRO PARA t_client client = g_clients[fd] // Assumimos que client existe se chegamos aqui
    INTEIRO bytes_received

    INTEIRO space_in_buf = sizeof(client->read_buf) - 1 - client->read_len
    SE space_in_buf <= 0 ENTÃO
        RETORNAR // Buffer cheio, não pode ler mais no momento
    FIM SE

    bytes_received = recv(fd, client->read_buf + client->read_len, space_in_buf, 0)

    SE bytes_received <= 0 ENTÃO // Erro ou conexão fechada
        remove_client(fd)
        RETORNAR
    FIM SE

    client->read_len += bytes_received
    client->read_buf[client->read_len] = '\0' // Garante terminação nula

    PONTEIRO PARA CARACTERE current_line_start = client->read_buf
    PONTEIRO PARA CARACTERE newline_char

    ENQUANTO (newline_char = strstr(current_line_start, "\n")) != NULO FAÇA
        *newline_char = '\0' // Substitui '\n' por '\0' para isolar a linha

        sprintf(g_msg_buffer, "client %d: %s\n", client->id, current_line_start)
        broadcast_message(fd, g_msg_buffer)

        current_line_start = newline_char + 1 // Avança para o início da próxima potencial linha
    FIM ENQUANTO

    // Gerencia dados restantes no buffer de leitura
    INTEIRO processed_len = current_line_start - client->read_buf
    INTEIRO remaining_len = client->read_len - processed_len

    SE remaining_len > 0 ENTÃO
        memmove(client->read_buf, current_line_start, remaining_len)
        client->read_len = remaining_len
        client->read_buf[client->read_len] = '\0' // Garante terminação nula para os dados movidos
    SENÃO // Todos os dados foram processados
        client->read_len = 0
        client->read_buf[0] = '\0'
    FIM SE
FIM FUNÇÃO

FUNÇÃO handle_client_write(INTEIRO fd)
    PONTEIRO PARA t_client client = g_clients[fd]

    SE client->write_buf FOR NULO OU client->write_buf[0] == '\0' ENTÃO
        RETORNAR // Nada para enviar
    FIM SE

    INTEIRO to_send_len = strlen(client->write_buf)
    INTEIRO bytes_sent = send(fd, client->write_buf, to_send_len, 0)

    SE bytes_sent < 0 ENTÃO // Erro de envio
        remove_client(fd) // Considera que o cliente desconectou
        RETORNAR
    FIM SE
    SE bytes_sent == 0 E to_send_len > 0 ENTÃO // Conexão fechada pelo peer enquanto tentava enviar
        remove_client(fd)
        RETORNAR
    FIM SE

    SE bytes_sent < to_send_len ENTÃO
        // Nem tudo foi enviado, move o restante para o início do buffer
        memmove(client->write_buf, client->write_buf + bytes_sent, to_send_len - bytes_sent + 1) // +1 para o '\0'
    SENÃO
        // Tudo foi enviado, libera o buffer
        free(client->write_buf)
        client->write_buf = NULO
    FIM SE
FIM FUNÇÃO

FUNÇÃO PRINCIPAL main(INTEIRO argc, ARRAY DE PONTEIROS PARA CARACTERE argv)
    SE argc != 2 ENTÃO
        ft_putstr_fd("Wrong number of arguments\n", 2)
        exit(1)
    FIM SE

    INTEIRO port = atoi(argv[1])

    PARA INTEIRO i = 0 ATÉ MAX_SUPPORTED_FDS - 1 FAÇA
        g_clients[i] = NULO
    FIM PARA

    g_server_fd = socket(AF_INET, SOCK_STREAM, 0)
    SE g_server_fd < 0 ENTÃO fatal_error() FIM SE

    SE g_server_fd >= MAX_SUPPORTED_FDS ENTÃO // Verificação de segurança adicional
        close(g_server_fd)
        fatal_error()
    FIM SE

    g_max_fd = g_server_fd

    ESTRUTURA sockaddr_in servaddr
    // memset(&servaddr, 0, sizeof(servaddr));
    INICIALIZAR servaddr COM ZEROS // Equivalente a memset para zerar a estrutura
    servaddr.sin_family = AF_INET
    servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK) // 127.0.0.1
    servaddr.sin_port = htons(port)

    SE bind(g_server_fd, (PONTEIRO PARA sockaddr)&servaddr, sizeof(servaddr)) < 0 ENTÃO fatal_error() FIM SE
    SE listen(g_server_fd, LISTEN_BACKLOG) < 0 ENTÃO fatal_error() FIM SE

    FD_ZERO(&g_active_fds)
    FD_SET(g_server_fd, &g_active_fds)

    ENQUANTO VERDADEIRO FAÇA
        g_read_fds = g_active_fds
        FD_ZERO(&g_write_fds)

        // Prepara o conjunto de FDs para escrita
        PARA INTEIRO fd = 0 ATÉ g_max_fd FAÇA
            SE FD_ISSET(fd, &g_active_fds) E g_clients[fd] NÃO FOR NULO E g_clients[fd]->write_buf NÃO FOR NULO E g_clients[fd]->write_buf[0] != '\0' ENTÃO
                FD_SET(fd, &g_write_fds)
            FIM SE
        FIM PARA

        SE select(g_max_fd + 1, &g_read_fds, &g_write_fds, NULO, NULO) < 0 ENTÃO
            fatal_error() // Erro no select, geralmente não recuperável aqui
        FIM SE

        // Processa FDs prontos
        PARA INTEIRO current_fd = 0 ATÉ g_max_fd FAÇA
            SE FD_ISSET(current_fd, &g_read_fds) ENTÃO
                SE current_fd == g_server_fd ENTÃO
                    // Nova conexão
                    add_new_client()
                SENÃO
                    // Dados de um cliente existente
                    SE g_clients[current_fd] NÃO FOR NULO ENTÃO // Checagem de segurança
                        handle_client_read(current_fd)
                    FIM SE
                FIM SE
            FIM SE
            
            // Verifica se o cliente ainda existe após uma potencial remoção em handle_client_read
            SE FD_ISSET(current_fd, &g_write_fds) E g_clients[current_fd] NÃO FOR NULO ENTÃO
                handle_client_write(current_fd)
            FIM SE
        FIM PARA
    FIM ENQUANTO
    close(g_server_fd) // Inalcançável no loop infinito
    RETORNAR 0         // Inalcançável
FIM FUNÇÃO